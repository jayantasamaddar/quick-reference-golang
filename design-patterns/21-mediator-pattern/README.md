# Table of Contents

- [Table of Contents](#table-of-contents)
- [Mediator Pattern](#mediator-pattern)
  - [Introduction](#introduction)
  - [Use Cases](#use-cases)
  - [Implementation in Go](#implementation-in-go)
- [Summary](#summary)

---

# Mediator Pattern

## Introduction

The **Mediator** Design Pattern is a behavioral design pattern that promotes loose coupling between objects by introducing a **Mediator** object that facilitates communication between them. This pattern is useful when a set of objects need to communicate with each other, but direct communication between them would result in tight coupling and make the system difficult to maintain and extend.

In the **Mediator** pattern, objects do not communicate with each other directly. Instead, they communicate through a **Mediator** object, which encapsulates the communication logic. This allows for better modularity and easier maintenance of the system.

---

## Use Cases

The Mediator pattern is commonly used in scenarios where a set of objects need to communicate with each other, but direct communication between them would result in tight coupling and complexity. Some practical use cases where the Mediator pattern can be beneficial include:

1. **GUI frameworks**: In graphical user interface (GUI) frameworks, various components such as buttons, text fields, and menus may need to interact with each other based on user actions. A mediator can facilitate communication between these components without them needing to have direct references to each other, making the GUI code more modular and easier to maintain.

2. **Chat applications**: In chat applications, multiple users may need to send messages to each other. A mediator can manage the communication between users, handling message routing and delivery without the users needing to know about each other's existence.

3. **Air traffic control systems**: In air traffic control systems, multiple aircraft and control towers need to communicate with each other to coordinate flight paths and ensure safety. A mediator can manage the communication between aircraft and control towers, facilitating efficient routing and communication without each entity needing direct knowledge of all other entities.

4. **Event-driven systems**: In event-driven systems, multiple components may need to react to events generated by other components. A mediator can act as a central hub for event propagation, allowing components to publish and subscribe to events without directly depending on each other.

**Popular libraries and frameworks that use the Mediator pattern**:

1. **Java Message Service (JMS)**: JMS provides a messaging standard for Java applications, allowing components to communicate via message queues. JMS often employs the Mediator pattern to manage message routing and delivery between producers and consumers.

2. **Android Architecture Components**: Android Architecture Components, such as `LiveData` and `ViewModel`, promote a reactive programming model for building Android apps. These components often use the Mediator pattern to manage data flow between different parts of the app, such as UI controllers and data sources.

3. **Angular**: Angular is a popular JavaScript framework for building web applications. It employs the Mediator pattern in various features, such as event handling and component communication through services and dependency injection.

4. **Spring Framework**: The Spring Framework for Java provides support for building enterprise applications. It includes features such as Spring Integration, which uses the Mediator pattern to facilitate communication and integration between disparate systems and components.

Overall, the Mediator pattern is a valuable tool for managing complex communication scenarios in software systems, and it is widely used in various domains and frameworks.

---

## Implementation in Go

A Chat Room is a classic example of the Mediator pattern which decouples how two or more people can communicate. Even if one person has left the room, the messages can still be sent to the Chat Room (mediator) without running into issues.

```go
package main

import "fmt"

/*****************************************************************************/
// Participants that want to communicate with each other
/*****************************************************************************/
type Person struct {
	Name    string
	Room    *ChatRoom
	chatLog []string
}

// Factory Function to create a new person
func NewPerson(name string) *Person {
	return &Person{Name: name}
}

func (p *Person) Receive(sender, message string) {
	s := fmt.Sprintf("%s: %s", sender, message)
	fmt.Printf("[%s's chat session]: %s\n", p.Name, s)
	p.chatLog = append(p.chatLog, s)
}

func (p *Person) Send(message string) {
	p.Room.Broadcast(p.Name, message)
}

func (p *Person) SendPrivate(receiver, message string) {
	p.Room.Message(p.Name, receiver, message)
}

/*****************************************************************************/
// ChatRoom: This is the Mediator
/*****************************************************************************/

type ChatRoom struct {
	people []*Person
}

func (c *ChatRoom) Broadcast(sender, message string) {
	for _, p := range c.people {
		if sender != p.Name {
			p.Receive(sender, message)
		}
	}
}

func (c *ChatRoom) Message(sender, receiver, message string) {
	for _, p := range c.people {
		if receiver == p.Name {
			p.Receive(sender, message)
		}
	}
}

func (c *ChatRoom) Join(p *Person) {
	c.Broadcast("Room", fmt.Sprintf("%s has joined the chat!", p.Name))
	p.Room = c
	c.people = append(c.people, p)
}

func main() {
	// Chat Room
	room := ChatRoom{}

	// Users
	jayanta := NewPerson("Jayanta")
	rohit := NewPerson("Rohit")

	// Join Room
	room.Join(jayanta)
	room.Join(rohit)

	jayanta.Send("Hi Room!")
	rohit.Send("Oh, Hi Jayanta!")

	// New Person joins!
	simon := NewPerson("Simon")
	room.Join(simon)
	simon.Send("Hi Everyone!")

	// Private Message
	jayanta.SendPrivate(simon.Name, "Glad you could join us!")

	/*
		[Jayanta's chat session]: Room: Rohit has joined the chat!
		[Rohit's chat session]: Jayanta: Hi Room!
		[Jayanta's chat session]: Rohit: Oh, Hi Jayanta!
		[Jayanta's chat session]: Room: Simon has joined the chat!
		[Rohit's chat session]: Room: Simon has joined the chat!
		[Jayanta's chat session]: Simon: Hi Everyone!
		[Rohit's chat session]: Simon: Hi Everyone!
		[Simon's chat session]: Jayanta: Glad you could join us!
	*/

}
```

---

# Summary

- Create a Mediator as a central component and have each object point to it, instead of each other.
- Mediator engages in bi-directional communication with the connected components.
- Mediator has methods the mediator can call.
- Components have methods that the mediator can call.
- Event processing (e.g. Rx) libraries make communication easier to implement.

---
