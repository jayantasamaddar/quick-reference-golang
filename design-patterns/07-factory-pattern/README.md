# Table of Contents

- [Table of Contents](#table-of-contents)
- [Factory Pattern](#factory-pattern)
  - [Introduction](#introduction)
  - [Factory Function](#factory-function)
  - [Interface Factory](#interface-factory)
  - [Factory Generator](#factory-generator)
  - [Prototype Factory](#prototype-factory)
- [Summary](#summary)

---

# Factory Pattern

## Introduction

Factories are ways of controlling how an object is constructed - kind of how factories work in the real world.
A Factory is just a component which is solely responsible for the wholesale (not piece-wise, that is seen in the Builder) creation of objects.

**The Motivation**:

- Object creation logic becomes too convoluted.
- A struct with lots of lists and maps. You want to initialize those but you don't want to initialize them element-by-element every single time someone wants to use it, and call `make` only on whatever types that are actually required.
- Wholesale object creation (non-piecewise, unlike Builder) can be outsourced to:
  - A Separate Function (Factory Function a.k.a. Constructor)
  - That may exist in a separate struct (Factory)

---

## Factory Function

You may want to use a Factory Function to implement a default value for a struct field.

Let's try to implement a `Person` stuct whose default value for City is `Kolkata` if the Country is `India`.

```go
package main

import "fmt"

type Person struct {
	Name, City, Country string
}

// Factory Function: A standalone function that returns an instance of the struct that you want to create
func NewPerson(name, country string) *Person {
	p := &Person{Name: name, Country: country}
	switch p.Country {
	case "India":
		p.City = "Kolkata"
	default:
		p.City = ""
	}
	return p
}

func main() {
	// (1) Factory Function with default value
	fmt.Println(NewPerson("Michael", "Australia")) // &{Michael  Australia}
	fmt.Println(NewPerson("Jayanta", "India"))     // &{Jayanta Kolkata India}
}
```

---

## Interface Factory

When you have a Factory Function, you don't have to always return a struct. You can also return an interface that the struct conforms to.
This is beneficial at this prevents exposing the underlying struct and struct fields and only exposes the interface methods after the object initialization using the Factory Function.

This is a neat way of encapsulating information and having the factory function expose just the interface we can work with.

In **`lib/InterfaceFactory.go`**:

```go
package lib

import "fmt"

type person struct {
	name string
	age  int
}

type Person interface {
	SayHello()
}

func (p *person) SayHello() {
	fmt.Printf("Hi, my name is %s, I am %d years old.\n", p.name, p.age)
}

func NewPerson(name string, age int) Person {
	return &person{name, age}
}
```

In **`main.go`**:

```go
func main() {
    // Interface Factory
	p := lib.NewPerson("Tom", 30)
	p.SayHello() // Hi, my name is Tom, I am 30 years old.
}
```

---

## Factory Generator

The idea here is to return a factory generator that can generate factories. There can be two approaches:

- Functional Approach:
- Structural Approach:

> The only real benefit of the structural approach is that after the factories are generated by the Functional approach, they cannot be modified. This makes the factory generators in the structural approach reusable, provided you don't need the old factory generator.

```go
package main

import "fmt"

type Employee struct {
	Name, Position, Designation string
	AnnualIncome                int
}

// Functional Approach
func NewEmployeeFactory(position string) func(name, designation string, annualIncome int) *Employee {
	return func(name, designation string, annualIncome int) *Employee {
		return &Employee{name, position, designation, annualIncome}
	}
}

// Structural Approach
type EmployeeFactory struct {
	Position string
}

func (f *EmployeeFactory) Create(name, designation string, annualIncome int) *Employee {
	return &Employee{name, f.Position, designation, annualIncome}
}

func NewEmployeeFactoryStructural(position string) *EmployeeFactory {
	return &EmployeeFactory{position}
}

func main() {
	// (3a) Demonstration of Factory Generators: Functional Approach
	engineerGenerator := lib.NewEmployeeFactory("Engineer")
	e1 := engineerGenerator("Amarpreet Singh", "Senior DevOps Engineer", 6000000)
	e2 := engineerGenerator("Jayanta Samaddar", "Senior Software Engineer", 4000000)
	fmt.Println(e1, e2) // &{Amarpreet Singh Engineer Senior DevOps Engineer 6000000} &{Jayanta Samaddar Engineer Senior Software Engineer 4000000}

	// (3b) Demonstration of Factory Generators: Structural Approach
	engineerGeneratorStructural := lib.NewEmployeeFactoryStructural("Engineer")
	es1 := engineerGeneratorStructural.Create("Amarpreet Singh", "Senior DevOps Engineer", 6000000)
	es2 := engineerGeneratorStructural.Create("Jayanta Samaddar", "Senior Software Engineer", 4000000)
	fmt.Println(es1, es2) // &{Amarpreet Singh Engineer Senior DevOps Engineer 6000000} &{Jayanta Samaddar Engineer Senior Software Engineer 4000000}

	employeeFactoryGenerator.Position = "Manager"
	es3 := employeeFactoryGenerator.Create("Maulik Vinchi", "Engineering Manager", 3500000)
	fmt.Println(es3) // &{Maulik Vinchi Manager Engineering Manager 3500000}
}
```

---

## Prototype Factory

A Prototype Factory is a design pattern that combines the concepts of prototyping and factories. In this pattern, instead of creating objects through a traditional constructor or factory method, you create new objects by copying an existing object, known as the prototype. The prototype serves as a template for creating new instances, and the copying process is often referred to as cloning.

Key components of a Prototype Factory pattern:

- **Prototype Interface/Abstract Class**: Defines a method for cloning itself. This can be an interface or an abstract class that declares the cloning method.

- **Concrete Prototypes**: Classes that implement the prototype interface or extend the abstract class. These classes provide the actual implementation of the cloning method.

- **Client**: The code that uses the prototype objects to create new instances. Instead of creating objects using constructors or factories, the client clones an existing prototype.

In `lib/PrototypeFactory.go`:

```go
package lib

const (
	Male = iota
	Female
)

// Prototype interface
type Cloneable interface {
	Clone() Cloneable
}

// Concrete prototype
type Candidate struct {
	Name, Title string
	Married     bool
	Age         int
}

func NewCandidate(name string, gender, age int, married bool) *Candidate {
	c := &Candidate{Name: name, Age: age, Married: married}
	switch gender {
	case Male:
		c.Title = "Mr."
	case Female:
		if c.Married {
			c.Title = "Mrs."
		} else {
			c.Title = "Ms."
		}
	default:
		panic("gender should either be Male or Female")
	}
	return c
}

func (c *Candidate) CloneInto(gender int, married bool) *Candidate {
	ca := &Candidate{Name: c.Name, Married: married, Age: c.Age}
	switch gender {
	case Male:
		ca.Title = "Mr."
	case Female:
		if ca.Married {
			ca.Title = "Mrs."
		} else {
			ca.Title = "Ms."
		}
	default:
		panic("gender should either be Male or Female")
	}
	return ca
}
```

In **`main.go`**:

```go
package main

import "fmt"

func main() {
	// Prototype Factory (Cloning a Factory)
	mr := lib.NewCandidate("Bryan Adams", lib.Male, 56, true)
	ms := mr.CloneInto(lib.Female, false)
	ms.Name = "Adele"
	ms.Age = 42
	mrs := ms.CloneInto(lib.Female, true)
	mrs.Name = "Priyanka Chopra"
	mrs.Age = 36
	fmt.Println(mr, ms, mrs) // &{Bryan Adams Mr. true 56} &{Adele Ms. false 42} &{Priyanka Chopra Mrs. true 36}
}
```

---

# Summary

- A Factory Function (a.k.a. constructor) is a helper function for making sturct instances
- A Factory is any entity that can take care of object creation
- Can be a function or a dedicated struct
